https://www.saaspegasus.com/guides/modern-javascript-for-django-developers/integrating-javascript-pipeline/
    this was handy

reading https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html

author seems a bit crotchety

tuples are mutable, makes sense in the context of this being js but good to keep in mind

    "Function syntax includes parameter names. This is pretty hard to get used to!
        let fst: (a: any, b: any) => any = (a, b) => a;
        // or more precisely:
        let fst: <T, U>(a: T, b: U) => T = (a, b) => a;"

    "Note that inference will work in any order, but intellisense will only work left-to-right, so TypeScript prefers to declare map with the array first:
        declare function map<T, U>(ts: T[], f: (t: T) => U): U[];"

    const prevents reassignment
    readonly prevents a property from being reassigned

    ReadonlyArray<T>, neat

https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html
    less verbose

https://www.typescriptlang.org/docs/handbook/2/basic-types.html

    "one of TypeScript’s core values: much of the time, you will know better than TypeScript."
        ????????

    --noEmitOnError
        good

    always use lowercase string, number, boolean as opposed to eg String, Number

    number[] is an array of numbers

    interfaces are extensible, type aliases are not

ok i made it as far as https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-assertions
and think i'm just gonna take a quick break and do aoc 2023 day 1

ok ez cool
back to https://www.typescriptlang.org/docs/handbook/2/everyday-types.html

    so "type assertions" are "as Foo"
    assertion is a weird name for them bc there is no runtime behavior
    instead i'd call them casts

    https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-inference

    this one's funky
    as "GET" or as const
    weird

    ! is dangerous, claims the value is non-null but with no extra runtime checking

cool
https://www.typescriptlang.org/docs/handbook/2/narrowing.html

    typeof checks are "type guards"

    https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions

        nice i like this

ok i was working on part 2 but i have to go

ok interesting


  const digitWords = {
    "one": "1",
    "two": "2",
    "three": "3",
    "four": "4",
    "five": "5",
    "six": "6",
    "seven": "7",
    "eight": "8",
    "nine": "9",
  };

  const lines = rawLines.map((line) =>
    line.replace(
      /one|two|three|four|five|six|seven|eight|nine/g,
      (match) => digitWords[match],
    )
  );

that was complaining on this line
      (match) => digitWords[match],

bc `match` is a string, and string can't be used to index digitWords

so i was like, what can i do here

i tried doing digitWords[match as keyof digitWords],

but that didn't work bc digitWords is an object, not a type
but this works:
      (match) => digitWords[match as keyof typeof digitWords],

keyof typeof
neat!

ok so back to part 2
my solution isn't working
i think it's because for lines like this

eightwothree

they want you to turn it into 823
instead of 8wo3

hm
well maybe not
for instance my input has this line

1four2eightseven8one3eightwogrr

the eight doesn't matter
just the two

so i think what we want to do is
do two passes over each line
replace the first found worded digit from the left
and the first found one from the right

don't care about the middle

DONE how do i debug typescript in deno?

ok i guess that doesn't work

there must be a line somewhere that's like
zzzeightwozzz

oh well

ok done

so now let's figure out how to run+debug TS with deno + vscode

https://docs.deno.com/runtime/manual/references/vscode_deno#using-the-debugger

ok cool that works great
i'll have to tweak launch.json to target each new file i'm working on
but that seems ok

ok now let's read more typescript docs

https://www.typescriptlang.org/docs/handbook/2/functions.html

https://www.typescriptlang.org/docs/handbook/2/functions.html#call-signatures

GROSS
JESUS

this is interesting
https://www.typescriptlang.org/docs/handbook/2/functions.html#specifying-type-arguments
    const arr = combine<string | number>([1, 2, 3], ["hello"]);

neat

good advice about avoiding overuse of generics:

    Remember, type parameters are for relating the types of multiple values. If a
    type parameter is only used once in the function signature, it’s not relating
    anything.

ok, was about to start https://www.typescriptlang.org/docs/handbook/2/functions.html#function-overloads

but let's do day 2 now

ok part 1 ez

back to docs
overloads are gross, don't do them

unknown is interesting

https://www.typescriptlang.org/docs/handbook/2/functions.html#parameter-destructuring this is good

ok cool done with fn page
next up i have these two tabs open
https://code.visualstudio.com/docs/typescript/typescript-tutorial
https://code.visualstudio.com/docs/languages/typescript
which one should i do? both?
the second one looks like a longer version of the first one

ok whatever i did the second one and it had no new info, nbd

ok day 2 part 2 done
tomorrow let's pick up again with https://www.typescriptlang.org/docs/handbook/2/objects.html

ok actually first let's do day 3

ok it's a grid with neighbors again

wow ok so typescript doesn't seem to have a range(5, 10) function
instead you have to do like
    console.log([...Array(5).keys()])
to do range (0, 5)
and i'm not sure yet how to do range (5, 10)

so anyway i'm trying to like
come up with a list of the coordinates of all symbols in this grid
and trying to start off by doing it in a functional way w map and stuff

i should be able to do this super easy w a couple forloops but i want to figure out how to do it this other way
so where do i start?

DONE rewrite grid stuff w class syntax?

ok wow
day 3 is interesting
because you're not summing digits, you're summing NUMBERS

so like for instance in this sample input
    467..114..
    ...*......
    ..35..633.
    ......#...
    617*......
    .....+.58.
    ..592.....
    ......755.
    ...$.*....
    .664.598..

you're supposed to be summing numbers like eg 467, 35, 633

so i still think my overall approach (find coordinates of digits, then find coordinates of numbers next to them) is reasonable
but i need to represent and look up numbers with a bit more ceremony
i think a number could look like

interface Number {
    value: number,
    coordinates: number[][]
}

i guess you could store them in a dict of {coordinates: number}
this all seems doable

ok cool so i made some progress
DONE next up is to turn Number[] into a map of {[x, y]: Number}
but DONE the main thing i'm worried about here is - can you use an array as a map key in javascript?
js does comparison by reference, not equality, right? so shouldn't that cause key lookups to always fail?
we'll see next time!

ok yeah so that is true, if you do [1, 2, 3] as your map key you can't look it up again later
but you can use string keys like "1,2,3" instead
lol

ok finished day 3
day 4 part 1 was ez

let's go back to reading docs a bit

https://www.typescriptlang.org/docs/handbook/2/objects.html

    good notes here about destructuring syntax

    interesting note about readonly properties
    readonly just prevents reassignment, not mutation
    still potentially a useful signal to developers though? meh

    index signatures are interesting - i wouldn't want to use them often but i can see it being helpful in typing some js code
    and also maybe in, like, dealing with representing user input / some not-well-known api responses / etc

    oh i see, it's an INDEX signature
    so it describes what happens if you do eg foo[1]

    bleh in general i think i'd avoid this feature

    excess property checks seem useful

    hm at one point they say that the difference between extending and intersecting types is mainly around how
    each approach handles conflicts - but i don't think they actually say what each approach does in the presence of conflicts???

    interesting notes about how to use generics in the context of type aliases
    eg
        type OrNull<Type> = Type | null;

ok cool that was a useful page
gonna take a look at day 4 part 2 before leaving for the day

ok this is interesting
the fact that this "winning copies" behavior is directional - i.e. you only win stuff further down the list - is useful
ensures that this is bounded / can't have cycles

so we need to track the number of copies of each card that you have
either by putting .copies on Card itself,
or by having eg a tuple of [Card, number] with some good name

and you start off with 1 copy of each card

let's try just putting .copies on Card for now

ok ezpz

day 5 now

ok, part 1 implementation first pass done
but getting wrong answer
it says my answer is too low
why?

works fine on their example input
i don't feel like i have an off-by-one somewhere bc

    console.log(mapId(97, input.seedToSoil));
    console.log(mapId(98, input.seedToSoil));
    console.log(mapId(99, input.seedToSoil));
    console.log(mapId(100, input.seedToSoil));

    99
    50
    51
    100

so where could the issue be?
gotta examine the puzzle input i guess

ok nah that wasn't it
i just had a mistake when parsing the end of the input
and wasn't parsing the humidity-to-location ranges at all
whoops!

ok so now i have a first pass of part 2 running
it's running, but very slowly
i'm inclined to just say that's fine

what would i do if i wanted to optimize it?
first i'd want to profile it i guess
but i imagine most of the time i spent walking each list of ranges to either find the right range
or discover that the number isn't covered by a range

ok yeah my part 2 gave the right answer

well i guess i could take this opportunity to learn how to profile typescript when running it from the command line via deno

hm
https://docs.deno.com/runtime/manual/references/contributing/profiling exists but seems mainly about how to profile deno itself

i think i'd be better off figuring out how to run this in chrome and use their profiling tab

ok so i just made an index.html like this

    <html>
    <head><script src="day_5.js"></script></head>
    <body><button onclick="console.log(partTwo())">hi</button></body>
    </html>

and used tsc to compile the ts to js
it seems like 98.6% of the time is spent in partTwo(), in the forloops
and relatively little is spent in seedToLocation
which is interesting

i don't really understand why that's the case

ok whatever
i looked at reddit and i have no idea what people are talking about when they talk about their optimized solutions
just do not understand what they are saying
so i think day 5 is done and that's fine!!

let's read some docs

https://www.typescriptlang.org/docs/handbook/2/types-from-types.html
https://www.typescriptlang.org/docs/handbook/2/generics.html
https://www.typescriptlang.org/docs/handbook/2/keyof-types.html
https://www.typescriptlang.org/docs/handbook/2/typeof-types.html
https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html
https://www.typescriptlang.org/docs/handbook/2/conditional-types.html
    neat
https://www.typescriptlang.org/docs/handbook/2/mapped-types.html
    also neat
https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html
    actually pretty cool, re: detecting typos in eg "firstNameChanged"
    pretty neat!

ok let's do day 6
and after that i'll read https://www.typescriptlang.org/docs/handbook/2/classes.html

ok day 6 done
started a util.js file via https://examples.deno.land/import-export

skimmed the classes page
let's look at day 7

ok
so i think what i want to do is write a compareHands(a, b) function

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort

cool cool
day7 part 1 done
trying to figure out how to have a nice type that's a union of string literals

https://stackoverflow.com/questions/44480644/string-union-to-string-array

ok that's pretty cool

    const handTypeOrder = [
    "five of a kind",
    "four of a kind",
    "full house",
    "three of a kind",
    "two pair",
    "one pair",
    "high card",
    ] as const;
    type HandType = (typeof handTypeOrder)[number];

cool neat!
ok so now i think maybe i'll have some fun and play around with a pattern matching lib
https://github.com/gvergnaud/ts-pattern

hwo do i use this in deno?

ok so importing it is really easy

    import { match, P } from "npm:ts-pattern@5.0.6";

but it doesn't actually make my code any better, it was fine the way it was