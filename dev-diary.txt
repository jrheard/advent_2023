https://www.saaspegasus.com/guides/modern-javascript-for-django-developers/integrating-javascript-pipeline/
    this was handy

reading https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html

author seems a bit crotchety

tuples are mutable, makes sense in the context of this being js but good to keep in mind

    "Function syntax includes parameter names. This is pretty hard to get used to!
        let fst: (a: any, b: any) => any = (a, b) => a;
        // or more precisely:
        let fst: <T, U>(a: T, b: U) => T = (a, b) => a;"

    "Note that inference will work in any order, but intellisense will only work left-to-right, so TypeScript prefers to declare map with the array first:
        declare function map<T, U>(ts: T[], f: (t: T) => U): U[];"

    const prevents reassignment
    readonly prevents a property from being reassigned

    ReadonlyArray<T>, neat

https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html
    less verbose

https://www.typescriptlang.org/docs/handbook/2/basic-types.html

    "one of TypeScriptâ€™s core values: much of the time, you will know better than TypeScript."
        ????????

    --noEmitOnError
        good

    always use lowercase string, number, boolean as opposed to eg String, Number

    number[] is an array of numbers

    interfaces are extensible, type aliases are not

ok i made it as far as https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-assertions
and think i'm just gonna take a quick break and do aoc 2023 day 1

ok ez cool
back to https://www.typescriptlang.org/docs/handbook/2/everyday-types.html

    so "type assertions" are "as Foo"
    assertion is a weird name for them bc there is no runtime behavior
    instead i'd call them casts

    https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-inference

    this one's funky
    as "GET" or as const
    weird

    ! is dangerous, claims the value is non-null but with no extra runtime checking

cool
https://www.typescriptlang.org/docs/handbook/2/narrowing.html

    typeof checks are "type guards"

    https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions

        nice i like this

ok i was working on part 2 but i have to go

ok interesting


  const digitWords = {
    "one": "1",
    "two": "2",
    "three": "3",
    "four": "4",
    "five": "5",
    "six": "6",
    "seven": "7",
    "eight": "8",
    "nine": "9",
  };

  const lines = rawLines.map((line) =>
    line.replace(
      /one|two|three|four|five|six|seven|eight|nine/g,
      (match) => digitWords[match],
    )
  );

that was complaining on this line
      (match) => digitWords[match],

bc `match` is a string, and string can't be used to index digitWords

so i was like, what can i do here

i tried doing digitWords[match as keyof digitWords],

but that didn't work bc digitWords is an object, not a type
but this works:
      (match) => digitWords[match as keyof typeof digitWords],

keyof typeof
neat!